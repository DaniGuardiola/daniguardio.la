---
draft: false
title: Egolatron, the self-like â¤ï¸ detector for Twitter
description: |-
  If you are the kind of person who likes their own tweets... I'm watching you! ðŸ‘€
date: 2021-02-26
tags:
  - project
  - reverse_engineering
  - fun
  - javascript
  - web_extension
---

[![Available in the Chrome Web Store](/img/webstore-promo.png)](https://chrome.google.com/webstore/detail/egolatron/gncgbgdmioamlfdcliheeepnmgknlekm)

[![Get the source code in GitHub](/img/github-promo.png)](https://github.com/DaniGuardiola/egolatron)

> **Egolatry**
>
> The worship of the Ego.
>
> _My impulses are the real god that I must follow as it is the only persistent and real influence on me, My Ego is my God, I am a follower of Egolatry._
>
> â€” [Urban Dictionary](https://www.urbandictionary.com/define.php?term=Egolatry)

# Self-love

I've always found the idea of liking your own posts funny. I don't have anything against loving oneself, but it's still funny.

In fact, I might have done it myself in the past, but in a more... sneaky way: I used to like my main account tweets from my hidden account so that no one could find out. I'm not the one who's gonna judge.

![Love yourself!](self-love.jpg)

However, I still wanted to find those self-liked tweets, so I decided to create a web extension that does exactly that! I called it **Egolatron**.

<Tweet
  id='1328806906928967681'
  placeholder={`Have you ever liked your own tweet?
  
  Well, I built a browser extension that detects self-likes.
  
  I call it "Egolatron". Coming soon to the Chrome Web Store.`}
  userId='daniguardio_la'
  userName='Dani Guardiola_'
  date='2020-11-17'
/>

# The strategy

To create such an extension, we need to come up with a few things, including:

- A way to detect tweets loaded into the DOM by the Twitter client.
- A way to extract the tweet IDs and authors from the tweet elements.
- A way to get the list of users who liked those tweets (to check if the author is among them).
- Cool styles ðŸ˜Ž for self-liked tweets.
- A way to apply those styles.

The obvious part is that we're gonna need to load our script inside opened Twitter tabs. That's easily achieved with an [extension content script](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts). We just need to declare it in the [manifest](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json):

```json
{
  "content_scripts": [
    {
      "matches": ["https://twitter.com/*"],
      "js": ["content-script.js"]
    }
  ]
}
```

Then, the basic workflow is the following:

1. Detect new tweets.
2. Analyze them to find out if they're self-liked.
3. When self-liked tweets are visible on the screen, render the styles.

# Implementation

> You can check the full implementation [here](https://github.com/DaniGuardiola/egolatron/blob/main/extension/content-script.js) (it's open source!). These are only some simplified fragments that I think are worth sharing, but they are mostly pseudo-code.

## Detecting tweets

There are many ways to go about this, but I didn't want to make things complicated, so I opted for a simple (but far from perfect approach).

Here are two important facts I found about DOM tweets:

- They are `<article>` elements.
- They all contain a link to the tweet itself that looks like this:

  `https://twitter.com/<author>/status/<id>`

  This link is often the tweet date:

  ![The date links to the tweet itself](tweet-link.png)

With this information, I coded a function that detects them:

```javascript
function getDOMTweets () {
  // get all article elements, as they are potential tweets
  const tweetEls = [...document.querySelectorAll('article')]
  return tweetEls
    .map(element => {
      // obtain all links inside the article element
      const links = [...element.querySelectorAll('a')]
      let match
      links.forEach(function (link) {
        // tweets contain at least one link matching this regexp pattern,
        // which also captures the username and tweet ID
        const pattern = /^https:\/\/twitter\.com\/([a-zA-Z0-9_]+)\/status\/([0-9]+)\/?$/
        match = link.href.match(pattern) || match
      })
      if (!match) return // no match, this is not a tweet
      const user = match[1] // first capture group contains the username
      const id = match[2] // second capture group contains the tweet ID
      return { user, id, element }
    })
    .filter(item => item) // filter out non-tweets
}
```

This function will return all detected tweets in the form of an array of `{ user, id, element }` objects.

To keep the list of tweets up-to-date, we need to execute this periodically in a loop:

```javascript
async function updateTweetsLoop () {
  // obtain the tweets from DOM
  const domTweets = getDOMTweets()
  // "update" each tweet found
  domTweets.forEach(updateTweet)
  // recursively call this function again in 200 ms
  setTimeout(() => updateTweetsLoop(100), 100)
}

function updateTweet (tweetData) {
  // do stuff...
}
```

## Analyzing tweets

Now that we have the tweets, we need to check if they've been self-liked.

The straightforward way to achieve this is by retrieving the list of users who liked a certain tweet, and looking for the author on it.

We can find out about this API call by using the ["Network" tab from the DevTools](https://developers.google.com/web/tools/chrome-devtools/network):

1. Open the DevTools panel and go to the "Network" tab.
2. Trigger the API call by opening the like list of a tweet.
   ![The button to open tweet likes](like-ui.png)
3. Inspect the request using the DevTools.

By doing this we can see that the resource we need is `api.twitter.com/2/timeline/liked_by.json?tweet_id=<ID>`.

The API requires an authentication token among the request headers:

![Auth token](token-1.png)

It's almost as if this token is screaming.

![AAAAAAAAAAAAAA](token-2.png)

After spending some time looking for this token, I finally found it in a JavaScript file by searching for it on the DevTools with a regular expression:

![Token found!](token-3.png)

It seems like it is included in the main JavaScript bundle of the application. This file's name is `main.<hash>.js` and it is being loaded at the end of the body with a `<script>` tag. It is also being preloaded with a `<link rel="preload" as="script">` in the `<head>`:

![Main bundle preload](token-4.png)

If we take a look at a formatted version of this file, we can spot the token there:

![The token inside the main bundle](token-5.png)

With this knowledge, we can do something like this to obtain this token:

```javascript
async function getBearerToken () {
  // find the link tag and get its 'href' value
  const scriptUrl = document.querySelector(
    'link[href^="https://abs.twimg.com/responsive-web/client-web/main."]'
  ).href
  // fetch the file and get it as text
  const scriptContent = await (await fetch(scriptUrl)).text()
  // extract the bearer token
  const bearerToken = scriptContent.match(/"(AAAA[a-zA-Z0-9%]*)/)[1]
  return bearerToken
}
```

Notice how we are looking for the `<link>` tag by using the selector `link[href^=.../main.]`. This is because tools like Webpack add hashes to these bundles.

This means that a bundle could be named `main.123456789.js` in one build and `main.abcdefghi.js` in the next one. To make our selector resilient to hash changes, we are using the `[attr^=value]` selector, which matches an element that has the attribute `attr` with a value that starts with `value`.

Then we are using the URL to re-fetch the script (as text). Finally, we use a regular expression to find the bearer token inside the minified bundle code.

This method is more or less equivalent to this method of fixing cars:

![Car repair!](token-6.png)

But you know what? It works! Now we have everything we need to use the API for our evil purposes ðŸ˜ˆ. Only 180 times every 15 minutes though, because it is rate-limited ðŸ˜”.

```javascript
function updateTweet (tweetData) {
  checkIfSelfLiked(tweetData)
}
```

Of course, the `updateTweet` function is called from inside the loop, which is executed constantly. We don't want our script to make a bazillion API calls (remember the rate limit), so we need to check whether it is a new tweet or if it has already been checked:

```javascript
function updateTweet (tweetData) {
  if (isNewTweet(tweetData)) {
    checkIfSelfLiked(tweetData)
  }
}
```

When the check is done, we will store the result in memory to use it later.

## Cool styles ðŸ˜Ž

I thought it'd be fun to style self-liked tweets in a cool and funny way.

I wanted to give those tweets a "medal", so I made this SVG of a medal using Inkscape:

![Egolatron medal](medal.png)

Then, whenever a self-lifed tweet was visible, I inyected it into the element and added a class for additional styles:

```javascript
function renderSelfLiked (tweetElement) {
  tweetElement.element.insertAdjacentHTML('beforeend', SVG_MEDAL)
  tweetElement.classList.add('self-liked')
}
```

The additional styles take care of three important things:

- Animate the medal dropping initially
- Animate the swinging of the medal
- Add a top red border to the tweet

These CSS styles look like this:

```css
.self-liked {
  border-top: solid red 4px;
}

.self-liked svg {
  top: -20px;
  animation-duration: 0.5s, 2s;
  animation-name: medal_drop, medal_swing;
  animation-iteration-count: 1, infinite;
}
@keyframes medal_drop {
  0% {
    top: -95px;
  }
  100% {
    top: 0;
  }
}
@keyframes medal_swing {
  0% {
    transform: rotate(-4deg) translateX(4px);
  }
  50% {
    transform: rotate(4deg) translateX(-4px);
  }
  100% {
    transform: rotate(-4deg) translateX(4px);
  }
}
```

- The `medal_drop` animation happens once (at the beginning) because it has an `animation-iteration-count` value of `1`.
- The `medal_swing` animation repeats infinitely because it has an `animation-iteration-count` value of `infinite`.

## Applying the cool styles

The `updateTweet` now needs to render these styles for self-liked tweets:

```javascript
function updateTweet (tweetData) {
  if (isNewTweet(tweetData)) {
    checkIfSelfLiked(tweetData)
  } else if (isSelfLiked(tweetData)) {
    renderSelfLiked(tweetData.element)
  }
}
```

Additionally, I wanted these styles to render only once the tweet is fully visible (inside the viewport of the browser). We can assert that with a function like this:

```javascript
function isElementVisible (element) {
  const rect = element.getBoundingClientRect()
  return rect.top >= 0 && rect.bottom <= window.innerHeight
}
```

The `.getBoundingClientRect()` function will give us the position of the element (we need `top` and `bottom`). We can then do the following checks:

- The top of the element is below the top of the viewport (zero or more).
- The bottom of the element is above the bottom of the viewport (less than `window.innerHeight`, which is the height of the viewport).

If both are true, then the element is fully visible.

# How to look under the hood

Other than by reading the code itself, you can enable three baked-in debugging options. To do this, you need to open the DevTools console, and switch to the extension context ("Egolatron" instead of "top" in the dropdown). Then, execute the following:

- For detailed logs: `_egolatron.setLog(true)`
- For detailed stats: `_egolatron.setStats(true)`
- For debug styles: `_egolatron.setDebug(true)`

To disable, pass `false` instead.

Enabling debug styles will also enable logs and stats, overriding their individual settings. The debug styles will show a blue border for tweets that are being analyzed, green for tweets confirmed to not be 'self-liked' and red for 'self-liked' tweets (this will replace the fancy styles with the animated medal). Oh, and purple means that the API request for that tweet returned an error.

---

[![Available in the Chrome Web Store](/img/webstore-promo.png)](https://chrome.google.com/webstore/detail/egolatron/gncgbgdmioamlfdcliheeepnmgknlekm)

[![Get the source code in GitHub](/img/github-promo.png)](https://github.com/DaniGuardiola/egolatron)

Hope you enjoy it!

If you find funny self-liked tweets, [please send them my way](https://twitter.com/daniguardio_la) so we can share a laugh.

Also, I have some ideas for the future of this extension, like adding a stats UI or expanding to other platforms like Instagram or Facebook.

Which one do you want to see first? Wanna help me build those features? [Hit me up!](mailto:hi@daniguardio.la)
